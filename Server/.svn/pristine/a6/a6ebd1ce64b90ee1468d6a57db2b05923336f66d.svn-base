package manager

import (
	"Common/Table"
	"Common/Utils/define"
	"Common/Utils/helper"
	"Common/Utils/message"
	"Game/player"
	"cmp"
	"fmt"
	"log/slog"
	"math"
	"slices"
)

func AddItems(p *player.Player, items *def.Items) (err error) {
	organizeItems(items)

	// todo 背包容量判断

	for _, item := range *items {
		err = addItem(p, item.Id, item.Num)
		if err != nil {
			return err
		}
	}

	slices.SortFunc(p.Items, func(a, b *def.Item) int {
		if a.Id == b.Id {
			return cmp.Compare(b.Num, a.Num)
		}
		return cmp.Compare(a.Id, b.Id)
	})

	// todo 同步消息

	return
}

func SubItems(p *player.Player, items *def.Items) (err error) {
	organizeItems(items)
	if !hasEnoughItems(p, items) {
		err = fmt.Errorf("SubItems: no enough items")
		return
	}

	for _, item := range *items {
		err = subItem(p, item.Id, item.Num)
		if err != nil {
			return
		}
	}

	// todo 同步消息

	return
}

// 根据堆叠限制组织道具
func organizeItems(items *def.Items) {
	var (
		mapItems = make(map[int32]int64)
		data     *Table.TbItem
		maxPile  int32
	)

	for _, item := range *items {
		if item.Num > 0 {
			mapItems[item.Id] += int64(item.Num)
		}
	}
	items.Clear()

	for id, _ := range mapItems {
		data = Table.Table.TbConfigItem.FindById(id)
		if data == nil {
			slog.Warn("organizeItems: item Id not found", slog.Any("Id", id))
			continue
		}

		if data.MaxPile > 0 {
			maxPile = data.MaxPile
		} else {
			maxPile = math.MaxInt32
		}

		// 拆分超过堆叠上限的物品
		for {
			if mapItems[id] <= 0 {
				break
			}

			var item def.Item
			item.Id = id
			if mapItems[id] > int64(maxPile) {
				item.Num = maxPile
				mapItems[id] -= int64(maxPile)
			} else {
				item.Num = int32(mapItems[id])
				mapItems[id] = 0
			}
			items.Append(&item)
		}
	}

	return
}

func addItem(p *player.Player, id, num int32) (err error) {
	if num <= 0 {
		err = fmt.Errorf("AddItem: num <= 0")
		return
	}

	data := Table.Table.TbConfigItem.FindById(id)
	if data == nil {
		err = fmt.Errorf("AddItem: item id not found")
		return
	}

	switch id {
	case def.GoldId:
		p.Gold = helper.SafeAdd(p.Gold, num)
	default:
		// 道具合并
		if data.MaxPile > 1 {
			for _, item := range p.Items {
				if item.Num+num <= data.MaxPile {
					item.Num = item.Num + num
					return
				} else if num < data.MaxPile {
					num -= data.MaxPile - item.Num
					item.Num = data.MaxPile
				}
			}
		}

		// 道具堆叠已经在外面判断
		if num > 0 {
			p.Items.Append(&def.Item{
				Item: message.Item{Id: id, Num: num},
				// todo ID生成
			})
		}
	}

	return
}

func subItem(p *player.Player, id, num int32) (err error) {
	if num <= 0 {
		err = fmt.Errorf("SubItem: num <= 0")
		return
	}

	data := Table.Table.TbConfigItem.FindById(id)
	if data == nil {
		err = fmt.Errorf("SubItem: item id not found")
		return
	}

	// 道具是否充足已经在外面判断
	switch id {
	case def.GoldId:
		p.Gold = helper.SafeSub(p.Gold, num)
	default:
		for i := len(p.Items) - 1; i >= 0; i-- {
			if num <= 0 {
				break
			}

			if p.Items[i].Id != id {
				continue
			}

			if p.Items[i].Num-num > 0 {
				p.Items[i].Num -= num
				return
			} else {
				num -= p.Items[i].Num
				p.Items.Delete(i)
			}
		}
	}

	return
}

func hasEnoughItems(p *player.Player, items *def.Items) bool {
	var mapItems = make(map[int32]int32)

	for _, item := range *items {
		if item.Num > 0 {
			mapItems[item.Id] += item.Num
		}
	}

	for id, num := range mapItems {
		switch id {
		case def.GoldId:
			if p.Gold < num {
				return false
			}
		default:
			for _, item := range p.Items {
				if item.Id == id {
					num -= item.Num
					if num <= 0 {
						break
					}
				}
			}
			if num > 0 {
				return false
			}
		}
	}

	return true
}

func PrintItemsInfo(p player.Player) {
	for _, item := range p.Items {
		fmt.Println(item)
	}
	fmt.Println("Gold:", p.Gold)
}
