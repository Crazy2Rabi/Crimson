package def

import (
	"Common/message"
	"cmp"
	"fmt"
	"slices"
	"strconv"
	"strings"
)

// Item 物品
type Item struct {
	message.Item

	OnlyId int64
}

// 特殊物品Id
type ItemId = int32

const (
	GoldId    ItemId = 1001 // 金币
	DiamondId        = 1002 // 钻石
)

// 物品类型
type ItemType int32

const (
	Materials ItemType = iota // 材料
	Resources                 // 资源
	Equip                     // 装备
	Max
)

type Items []*Item

func (p Items) FindById(id int32) *Item {
	n, found := slices.BinarySearchFunc(p,
		&Item{
			Item: message.Item{
				Id: id,
			},
		},
		func(a *Item, b *Item) int {
			return cmp.Compare(a.Id, b.Id)
		})

	if found {
		return p[n]
	}

	return nil
}

func (p *Items) Append(v *Item) {
	*p = append(*p, v)
}

func (p *Items) Delete(index int) {
	*p = append((*p)[:index], (*p)[index+1:]...)
}

func (p *Items) Clear() {
	*p = make(Items, 0)
}

func IsItemTypeValid(itemType ItemType) bool {
	return itemType >= 0 && itemType < Max
}

func StrToItemType(s string) (t ItemType, err error) {
	i, err := strconv.ParseInt(s, 10, 32)
	if err != nil {
		return
	}
	if !IsItemTypeValid(t) {
		err = fmt.Errorf("strToItemType():%s not valid", s)
	}
	return ItemType(i), nil
}

func StrToItems(s string) (t Items, err error) {
	var items Items

	parts := strings.Split(s, "|")
	for _, part := range parts {
		subParts := strings.Split(part, "_")
		if len(subParts) != 2 {
			err = fmt.Errorf("strToItem():%s not valid", s)
			return
		}

		id, err := strconv.ParseInt(subParts[0], 10, 32)
		if err != nil {
			err = fmt.Errorf("strToItem():%s Id not valid", s)
			return
		}

		num, err := strconv.ParseInt(subParts[1], 10, 32)
		if err != nil {
			err = fmt.Errorf("strToItem():%s Num not valid", s)
			return
		}

		item := &Item{
			Item: message.Item{
				Id:  int32(id),
				Num: int32(num),
			},
		}
		items = append(items, item)
	}

	return items, nil
}
