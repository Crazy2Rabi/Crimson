package genTable

// Tables结构体模板
var TableText = `package Table

// Code generated by genTable/gen.
// DO NOT EDIT.{{"\n"}}

import (
	"Common/Framework/config"
	"encoding/json"
	"fmt"
	"os"
)

// ParseRow 每个TbConfig结构体需要实现的接口
type ParseRow interface {
	ParseRow(row []string) (buf map[string]interface{}, err error)
}

// 读取json中的表数据
func Loader(file string) (buf []map[string]interface{}, err error) {
	if str, err := os.ReadFile(config.Instance().TableConfig.Path + file); err != nil {
		err = fmt.Errorf("loader table <%s> error: %v", file, err)
		return nil, err
	} else {
		buf = make([]map[string]interface{}, 0)
		if err = json.Unmarshal(str, &buf); err != nil {
			err = fmt.Errorf("loader table <%s> error: %v", file, err)
			return nil, err
		}
		return buf, nil
	}
}

type Tables struct {
	{{- range .TableConfigs}}
	TbConfig{{.StructName}} *TbConfig{{.StructName}}
	{{- end}}
}

var Table Tables

func (t *Tables) Init() (err error) {
	var buf []map[string]interface{}{{"\n"}}

	{{- range .TableConfigs}}
	if buf, err = Loader("{{.TableName}}.json"); err != nil { return }
	if t.TbConfig{{.StructName}}, err = New{{.StructName}}Config(buf); err != nil { return }
	{{"\n"}}
	{{- end}}

	return nil
}
`

// 一般表结构体模板
var TableConfigText = `package Table

import (
	{{- if .Utils}} "Common/Utils" {{- end}}
	{{- if .Def}} "Common/def" {{- end}}
	"encoding/json"
	"fmt"
	"strconv"
)

// Code generated by genTable/gen.
// DO NOT EDIT.{{"\n"}}

type Tb{{.StructName}} struct {
	{{- range .Fields}}
		{{.Name}} {{.Package}}{{.Type}} // {{.Desc}}
	{{- end}}
}

type TbConfig{{.StructName}} struct {
	dataMap map[{{.KeyType}}]*Tb{{.StructName}} // key = {{.KeyDesc}}
	dataList []*Tb{{.StructName}}
}

func (t *TbConfig{{.StructName}}) Clear() {
	t.dataMap = make(map[{{.KeyType}}]*Tb{{.StructName}})
	t.dataList = make([]*Tb{{.StructName}}, 0)
}

func (t *TbConfig{{.StructName}}) ParseRow(row []string) (buf map[string]interface{}, err error) {
	buf = make(map[string]interface{})
	{{- range .Fields}}
		{{/*不是数字类型的，例如枚举、自定义类型，一定要转换成string，否则后面的Add函数很难处理*/}}
		{{- if .IsNumber}}
		buf["{{.Name}}"], err = strconv.ParseInt(row[{{.Col}}], 10, 32)
		if err != nil {
			return nil, err
		}
		{{- else}}
		buf["{{.Name}}"] = row[{{.Col}}]
		{{- end}}
	{{- end}}
	return
}

func (t *TbConfig{{.StructName}}) Add(buf map[string]interface{}) (err error) {
	v := &Tb{{.StructName}}{}
	{{- range .Fields}}
	{
		var val string
		{{- if .IsNumber}}
		val = buf["{{.Name}}"].(json.Number).String();
		{{- else}}
		var ok bool
		if val, ok = buf["{{.Name}}"].(string); !ok {
			err = fmt.Errorf("{{.Name}} error")
			return
		}
		{{- end}}

		{{- if eq .Type "string"}}
		v.{{.Name}} = val
		{{/*自定义类型，统一用 StrTo类型 命名规则的函数来转换*/}}
		{{- else if .Package}}
		v.{{.Name}}, err = {{.Package}}StrTo{{.Type}}(val)
		if err != nil {
			err = fmt.Errorf("{{.Name}} error: %v", err)
			return
		}
		{{/*这里没有特殊处理浮点数类型，需要的时候再补充*/}}
		{{- else}}
		var n int64
		n, err = strconv.ParseInt(val, 10, 32)
		v.{{.Name}} = {{.Type}}(n)
		{{- end}}
	}
	{{- end}}

	{{- if eq (len .KeyName) 1}}
	key := v.{{index .KeyName 0}}
	{{- else if eq (len .KeyName) 2}}
	key := def.MakeTwoKey(v.{{index .KeyName 0}}, v.{{index .KeyName 1}})
	{{- end}}
	if _, ok := t.dataMap[key]; ok {
		err = fmt.Errorf("Duplicate elements")
		return
	}

	t.dataMap[key] = v
	t.dataList = append(t.dataList, v)
	return
}

func (t *TbConfig{{.StructName}}) FindById(id {{.KeyType}}) *Tb{{.StructName}} {
	return t.dataMap[id]
}

func New{{.StructName}}Config(bufs []map[string]interface{}) (t *TbConfig{{.StructName}},err error) {
	t = &TbConfig{{.StructName}}{}
	t.Clear()

	for _, buf := range bufs {
		if err = t.Add(buf); err != nil {
			return
		}
	}
	return
}
`
